use std::collections::HashMap;

use crate::{
    ast::{
        Assign, Binary, BlockStatement, Declaration, Expr, ExprKind, FnDecl, FunctionCall, If, Return, Root, Selector,
        Statement, Type, Var, While,
    },
    bytecode::{Function, Instruction, Program, Value},
    parser,
    pos::Pos,
    token::{Token, TokenKind},
};

pub trait Compiler {
    fn compile(&mut self) -> Result<Program, Error>;
}

#[derive(Debug)]
pub enum Error {
    ParseError(parser::Error),
    RedeclaredSymbol(Token),
    UndeclaredSymbol(Token),
    CannotAssignToFunction(Token),
    CannotAssignTo(ValType),
    HasNoField(ValType),
    UndefinedField { typ: ValType, field: Token },
    MismatchType { expected: ValType, got: ValType, pos: Pos },
    ReturnOnVoidFunc(Pos),
    MissingReturnValue(Pos),
    MissingMain,
}

impl From<parser::Error> for Error {
    fn from(err: parser::Error) -> Self {
        Error::ParseError(err)
    }
}

// TODO (jauhararifin): refactor this into non-recursive implementation.
// TODO (jauhararifin): add type checking.
pub struct SimpleCompiler {
    root: Root,

    type_analyzer: TypeAnalyzer,

    values: Vec<Value>,
    name_to_value_index: HashMap<String, usize>,
    value_counter: usize,

    functions: Vec<Function>,
    name_to_func_index: HashMap<String, usize>,
    function_counter: usize,
}

impl SimpleCompiler {
    pub fn new(root: Root) -> Self {
        // TODO: don't unwrap.
        let type_analyzer = TypeAnalyzer::new(&root).unwrap();

        Self {
            root,

            type_analyzer,

            values: Vec::new(),
            name_to_value_index: HashMap::new(),
            value_counter: 0,

            functions: Vec::new(),
            name_to_func_index: HashMap::new(),
            function_counter: 0,
        }
    }

    fn compile_func(&self, fn_decl: &FnDecl) -> Result<Function, Error> {
        let mut instructions = Vec::new();
        let mut ctx = FnContext::new(&fn_decl, &self.type_analyzer)?;

        instructions.extend(self.compile_block_stmt(&mut ctx, &fn_decl.body)?);

        Ok(Function {
            name: fn_decl.name.value.as_ref().unwrap().clone(),
            instructions,
        })
    }

    fn compile_statement(&self, ctx: &mut FnContext, expr: &Statement) -> Result<Vec<Instruction>, Error> {
        match expr {
            Statement::Block(stmt) => self.compile_block_stmt(ctx, stmt),
            Statement::Var(var) => self.compile_var(ctx, var),
            Statement::Assign(stmt) => self.compile_assign(ctx, stmt),
            Statement::Return(stmt) => self.compile_return(ctx, stmt),
            Statement::If(stmt) => self.compile_if(ctx, stmt),
            Statement::While(stmt) => self.compile_while(ctx, stmt),
            Statement::Expr(expr) => self.compile_expr_stmt(ctx, expr),
        }
    }

    fn compile_block_stmt(&self, ctx: &mut FnContext, stmt: &BlockStatement) -> Result<Vec<Instruction>, Error> {
        let mut instructions = Vec::new();
        ctx.add_block();

        for statement in stmt.body.iter() {
            instructions.extend(self.compile_statement(ctx, statement)?);
        }

        let num_locals = ctx.pop_block();
        instructions.push(Instruction::Pop(num_locals));

        Ok(instructions)
    }

    fn compile_var(&self, ctx: &mut FnContext, var: &Var) -> Result<Vec<Instruction>, Error> {
        let name = var.name.value.as_ref().unwrap().clone();
        let typ = self.type_analyzer.compile_type(&var.typ)?;

        if let Some(value) = &var.value {
            let value_type = self.type_analyzer.compile_expr(value);
            if !typ.assignable_by(&value_type) {
                return Err(Error::MismatchType {
                    expected: typ.clone(),
                    got: value_type,
                    pos: var.name.pos,
                });
            }
        }

        ctx.add_symbol(name, typ);
        if let Some(value) = &var.value {
            self.compile_expr(ctx, value)
        } else {
            Ok(vec![Instruction::Constant(self.empty_value(&var.typ)?)])
        }
    }

    fn compile_assign(&self, ctx: &mut FnContext, stmt: &Assign) -> Result<Vec<Instruction>, Error> {
        let value_type = self.type_analyzer.compile_expr(&stmt.value);
        let receiver_type = self.type_analyzer.compile_expr(&stmt.receiver);

        let type_matched = match stmt.op.kind {
            TokenKind::Assign => value_type == receiver_type,
            TokenKind::PlusAssign | TokenKind::MinusAssign | TokenKind::MulAssign | TokenKind::DivAssign => {
                value_type == receiver_type && value_type.is_number()
            }
            TokenKind::ModAssign | TokenKind::BitAndAssign | TokenKind::BitOrAssign | TokenKind::BitXorAssign => {
                value_type == receiver_type && value_type.is_int()
            }
            TokenKind::ShlAssign | TokenKind::ShrAssign => value_type.is_int() && receiver_type.is_int(),
            _ => panic!("got invalid assign op {:?}", stmt.op),
        };

        if !type_matched {
            return Err(Error::MismatchType {
                expected: receiver_type,
                got: value_type,
                pos: stmt.op.pos,
            });
        }

        let mut instructions = self.compile_expr(ctx, &stmt.value)?;

        if stmt.op.kind != TokenKind::Assign {
            let mut receiver = self.compile_expr(ctx, &stmt.receiver)?;
            let op = match stmt.op.kind {
                TokenKind::PlusAssign => Instruction::Add,
                TokenKind::MinusAssign => Instruction::Sub,
                TokenKind::MulAssign => Instruction::Mul,
                TokenKind::DivAssign => Instruction::Div,
                TokenKind::ModAssign => Instruction::Mod,
                TokenKind::BitAndAssign => Instruction::And,
                TokenKind::BitOrAssign => Instruction::Or,
                TokenKind::BitXorAssign => Instruction::Xor,
                TokenKind::ShlAssign => Instruction::Shl,
                TokenKind::ShrAssign => Instruction::Shr,
                _ => panic!("got invalid assign op {:?}", stmt.op),
            };

            receiver.extend(instructions);
            receiver.push(op);
            instructions = receiver;
        }

        instructions.extend(self.compile_assign_receiver(ctx, &stmt.receiver)?);

        Ok(instructions)
    }

    fn compile_assign_receiver(&self, ctx: &mut FnContext, expr: &Expr) -> Result<Vec<Instruction>, Error> {
        match &expr.kind {
            ExprKind::Ident(token) => self.compile_assign_ident_expr(ctx, &token),
            ExprKind::Selector(selector) => self.compile_assign_selector_expr(ctx, &selector),
            _ => Err(Error::CannotAssignTo(self.type_analyzer.compile_expr(expr))),
        }
    }

    fn compile_assign_ident_expr(&self, ctx: &mut FnContext, token: &Token) -> Result<Vec<Instruction>, Error> {
        let name = token.value.as_ref().unwrap();
        if let Some(index_type) = ctx.find_symbol(name) {
            Ok(vec![Instruction::SetLocal(index_type.index)])
        } else if let Some(index) = self.name_to_value_index.get(name) {
            Ok(vec![Instruction::SetGlobal(index.clone())])
        } else if self.name_to_func_index.contains_key(name) {
            Err(Error::CannotAssignToFunction(token.clone()))
        } else {
            Err(Error::UndeclaredSymbol(token.clone()))
        }
    }

    fn compile_assign_selector_expr(
        &self,
        ctx: &mut FnContext,
        selector: &Selector,
    ) -> Result<Vec<Instruction>, Error> {
        let field_name = selector.selection.value.as_ref().unwrap();

        let source_type = self.type_analyzer.compile_expr(selector.source.as_ref());
        let value_type = if let ValType::Struct { fields } = &source_type {
            if let Some(typ) = fields.get(field_name) {
                typ.clone()
            } else {
                return Err(Error::UndefinedField {
                    typ: source_type.clone(),
                    field: selector.selection.clone(),
                });
            }
        } else {
            return Err(Error::HasNoField(source_type));
        };

        let mut instructions = self.compile_expr(ctx, selector.source.as_ref())?;
        instructions.push(Instruction::SetProp(value_type.index));

        Ok(instructions)
    }

    fn compile_return(&self, ctx: &mut FnContext, stmt: &Return) -> Result<Vec<Instruction>, Error> {
        if let Some(return_type) = &ctx.return_type {
            if stmt.value.is_none() {
                return Err(Error::MissingReturnValue(stmt.ret.pos));
            }

            let val_type = self.type_analyzer.compile_expr(stmt.value.as_ref().unwrap());
            if !return_type.assignable_by(&val_type) {
                return Err(Error::MismatchType {
                    expected: return_type.clone(),
                    got: val_type,
                    pos: stmt.value.as_ref().unwrap().pos,
                });
            }
        } else if let Some(value) = &stmt.value {
            return Err(Error::ReturnOnVoidFunc(value.pos));
        }

        let mut instructions = if let Some(value) = &stmt.value {
            self.compile_expr(ctx, value)?
        } else {
            vec![]
        };

        instructions.push(Instruction::Ret);
        Ok(instructions)
    }

    fn compile_if(&self, ctx: &mut FnContext, stmt: &If) -> Result<Vec<Instruction>, Error> {
        let cond_type = self.type_analyzer.compile_expr(&stmt.cond);
        if !cond_type.is_bool() {
            return Err(Error::MismatchType {
                expected: ValType::Bool,
                got: cond_type,
                pos: stmt.cond.pos,
            });
        }

        // 1. cond
        // 2. jump_if_false (4.)
        // 3. body
        // 4. <the next instruction>

        let cond = self.compile_expr(ctx, &stmt.cond)?;
        let body = self.compile_block_stmt(ctx, &stmt.body)?;
        let exit = Instruction::JumpIfFalse(body.len() as isize + 1);

        let mut result = vec![];
        result.extend(cond);
        result.push(exit);
        result.extend(body);

        Ok(result)
    }

    fn compile_while(&self, ctx: &mut FnContext, stmt: &While) -> Result<Vec<Instruction>, Error> {
        let cond_type = self.type_analyzer.compile_expr(&stmt.cond);
        if !cond_type.is_bool() {
            return Err(Error::MismatchType {
                expected: ValType::Bool,
                got: cond_type,
                pos: stmt.cond.pos,
            });
        }

        // 1. cond
        // 2. jump_if_false (5.)
        // 3. body
        // 4. jump (1.)
        // 5. <the next instruction>

        let cond = self.compile_expr(ctx, &stmt.cond)?;
        let body = self.compile_block_stmt(ctx, &stmt.body)?;
        let exit = Instruction::JumpIfFalse(body.len() as isize + 1 + 1);
        let go_back = Instruction::Jump(-(body.len() as isize + 1 + cond.len() as isize));

        let mut result = vec![];
        result.extend(cond);
        result.push(exit);
        result.extend(body);
        result.push(go_back);

        Ok(result)
    }

    fn compile_expr_stmt(&self, ctx: &mut FnContext, expr: &Expr) -> Result<Vec<Instruction>, Error> {
        let mut instructions = self.compile_expr(ctx, expr)?;
        instructions.push(Instruction::Pop(1));
        Ok(instructions)
    }

    fn compile_expr(&self, ctx: &FnContext, expr: &Expr) -> Result<Vec<Instruction>, Error> {
        match &expr.kind {
            ExprKind::Ident(token) => self.compile_ident(ctx, token),
            ExprKind::IntegerLit(token) => self.compile_int_lit(token),
            ExprKind::FloatLit(_) => todo!(),
            ExprKind::StringLit(_) => todo!(),
            ExprKind::BoolLit(_) => todo!(),
            ExprKind::Binary(binary) => self.compile_binary(ctx, binary),
            ExprKind::Unary(_) => todo!(),
            ExprKind::FunctionCall(fn_call) => self.compile_func_call(ctx, fn_call),
            ExprKind::Cast(_) => todo!(),
            ExprKind::Selector(_) => todo!(),
        }
    }

    fn compile_ident(&self, ctx: &FnContext, token: &Token) -> Result<Vec<Instruction>, Error> {
        let name = token.value.as_ref().unwrap();
        if let Some(index_type) = ctx.find_symbol(name) {
            Ok(vec![Instruction::GetLocal(index_type.index)])
        } else if let Some(index) = self.name_to_value_index.get(name) {
            Ok(vec![Instruction::GetGlobal(index.clone())])
        } else if let Some(index) = self.name_to_func_index.get(name) {
            Ok(vec![Instruction::Constant(Value::Fn(index.clone()))])
        } else {
            Err(Error::UndeclaredSymbol(token.clone()))
        }
    }

    fn compile_int_lit(&self, token: &Token) -> Result<Vec<Instruction>, Error> {
        // TODO (jauhararifin): add capability to add context on preferred size.

        let int_lit: i32 = token.value.as_ref().unwrap().parse().unwrap();
        Ok(vec![Instruction::Constant(Value::I32(int_lit))])
    }

    fn compile_binary(&self, ctx: &FnContext, binary: &Binary) -> Result<Vec<Instruction>, Error> {
        let a_type = self.type_analyzer.compile_expr(binary.a.as_ref());
        let b_type = self.type_analyzer.compile_expr(binary.b.as_ref());

        let type_matched = match binary.op.kind {
            TokenKind::Eq | TokenKind::NotEq => a_type == b_type,
            TokenKind::Plus
            | TokenKind::Minus
            | TokenKind::Mul
            | TokenKind::Div
            | TokenKind::GT
            | TokenKind::LT
            | TokenKind::GTEq
            | TokenKind::LTEq => a_type == b_type && a_type.is_number(),
            TokenKind::Mod | TokenKind::BitAnd | TokenKind::BitOr | TokenKind::BitXor => {
                a_type == b_type && a_type.is_int()
            }
            TokenKind::Shl | TokenKind::Shr => a_type.is_int() && b_type.is_int(),
            TokenKind::And | TokenKind::Or => {
                if !a_type.is_bool() {
                    return Err(Error::MismatchType {
                        expected: ValType::Bool,
                        got: a_type,
                        pos: binary.a.pos,
                    });
                }
                if !b_type.is_bool() {
                    return Err(Error::MismatchType {
                        expected: ValType::Bool,
                        got: b_type,
                        pos: binary.b.pos,
                    });
                }
                true
            }
            _ => panic!(
                "got invalid operator while compiling binary expression: {:?}",
                binary.op
            ),
        };

        if !type_matched {
            return Err(Error::MismatchType {
                expected: a_type,
                got: b_type,
                pos: binary.b.pos,
            });
        }

        let mut instructions = self.compile_expr(ctx, binary.a.as_ref())?;
        instructions.extend(self.compile_expr(ctx, binary.b.as_ref())?);

        let ins = match binary.op.kind {
            TokenKind::Plus => Instruction::Add,
            TokenKind::Minus => Instruction::Sub,
            TokenKind::Mul => Instruction::Mul,
            TokenKind::Div => Instruction::Div,
            TokenKind::Mod => Instruction::Mod,
            TokenKind::BitAnd => Instruction::And,
            TokenKind::BitOr => Instruction::Or,
            TokenKind::BitXor => Instruction::Xor,
            TokenKind::Shl => Instruction::Shl,
            TokenKind::Shr => Instruction::Shr,
            TokenKind::And => todo!(),
            TokenKind::Or => todo!(),
            TokenKind::GT => Instruction::GT,
            TokenKind::LT => Instruction::LT,
            TokenKind::GTEq => Instruction::GTEq,
            TokenKind::LTEq => Instruction::LTEq,
            TokenKind::Eq => Instruction::Eq,
            TokenKind::NotEq => Instruction::NEq,
            _ => panic!(
                "got invalid operator while compiling binary expression: {:?}",
                binary.op
            ),
        };
        instructions.push(ins);

        Ok(instructions)
    }

    fn compile_func_call(&self, ctx: &FnContext, fn_call: &FunctionCall) -> Result<Vec<Instruction>, Error> {
        let mut instructions = Vec::new();
        for arg in fn_call.args.iter() {
            instructions.extend(self.compile_expr(ctx, arg)?);
        }
        instructions.extend(self.compile_expr(ctx, &fn_call.func)?);
        instructions.push(Instruction::Call);
        instructions.push(Instruction::Pop(fn_call.args.len()));

        Ok(instructions)
    }

    fn empty_value(&self, typ: &Type) -> Result<Value, Error> {
        Ok(match typ {
            Type::Primitive(token) => match token.kind {
                TokenKind::I8 => Value::I8(0),
                TokenKind::I16 => Value::I16(0),
                TokenKind::I32 => Value::I32(0),
                TokenKind::I64 => Value::I64(0),
                TokenKind::U8 => Value::U8(0),
                TokenKind::U16 => Value::U16(0),
                TokenKind::U32 => Value::U32(0),
                TokenKind::U64 => Value::U64(0),
                TokenKind::F32 => Value::F32(0.0),
                TokenKind::F64 => Value::F64(0.0),
                TokenKind::Bool => Value::Bool(false),
                _ => panic!("got invalid primitive type {:?}", token),
            },
            Type::Ident(_ident) => todo!(),
            Type::Struct(_strct) => todo!(),
        })
    }
}

impl Compiler for SimpleCompiler {
    fn compile(&mut self) -> Result<Program, Error> {
        for decl in self.root.declarations.iter() {
            match decl {
                Declaration::Fn(fn_decl) => {
                    let name = fn_decl.name.value.as_ref().unwrap().clone();

                    if self.name_to_func_index.contains_key(&name) {
                        return Err(Error::RedeclaredSymbol(fn_decl.name.clone()));
                    }
                    self.name_to_func_index.insert(name, self.function_counter);
                    self.function_counter += 1;
                }
                Declaration::Var(_var) => todo!(),
                Declaration::Type(_type_decl) => todo!(),
            }
        }

        for decl in self.root.declarations.iter() {
            match decl {
                Declaration::Fn(fn_decl) => {
                    let func = self.compile_func(fn_decl)?;
                    self.functions.push(func);
                }
                Declaration::Var(_var) => todo!(),
                Declaration::Type(_type_decl) => todo!(),
            }
        }

        let main_func = self.name_to_func_index.get("main").ok_or(Error::MissingMain)?;

        Ok(Program {
            executable: true,
            values: std::mem::take(&mut self.values),
            functions: std::mem::take(&mut self.functions),
            entry_point: main_func.clone(),
        })
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ValType {
    Int { signed: bool, size: u8 },
    Float { size: u8 },
    Bool,
    Struct { fields: HashMap<String, ValTypeField> },
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ValTypeField {
    index: usize,
    typ: ValType,
}

impl ValType {
    fn assignable_by(&self, typ: &ValType) -> bool {
        self.eq(typ)
    }

    fn is_int(&self) -> bool {
        match self {
            ValType::Int { signed: _, size: _ } => true,
            _ => false,
        }
    }

    fn is_number(&self) -> bool {
        match self {
            ValType::Int { signed: _, size: _ } | ValType::Float { size: _ } => true,
            _ => false,
        }
    }

    fn is_bool(&self) -> bool {
        self == &ValType::Bool
    }
}

struct TypeAnalyzer {
    name_to_type: HashMap<String, ValType>,
}

impl TypeAnalyzer {
    fn new(root: &Root) -> Result<Self, Error> {
        let mut result = Self {
            name_to_type: HashMap::new(),
        };

        // TODO (jauhararifin): handle type definition dependency.
        for decl in root.declarations.iter() {
            if let Declaration::Type(type_decl) = decl {
                result.name_to_type.insert(
                    type_decl.name.value.as_ref().unwrap().clone(),
                    result.compile_type(&type_decl.typ)?,
                );
            }
        }

        Ok(result)
    }

    fn compile_type(&self, typ: &Type) -> Result<ValType, Error> {
        Ok(match typ {
            Type::Primitive(token) => match token.kind {
                TokenKind::Bool => ValType::Bool,
                TokenKind::I8 => ValType::Int { signed: true, size: 8 },
                TokenKind::I16 => ValType::Int { signed: true, size: 16 },
                TokenKind::I32 => ValType::Int { signed: true, size: 32 },
                TokenKind::I64 => ValType::Int { signed: true, size: 64 },
                TokenKind::U8 => ValType::Int { signed: false, size: 8 },
                TokenKind::U16 => ValType::Int {
                    signed: false,
                    size: 16,
                },
                TokenKind::U32 => ValType::Int {
                    signed: false,
                    size: 32,
                },
                TokenKind::U64 => ValType::Int {
                    signed: false,
                    size: 64,
                },
                TokenKind::F32 => ValType::Float { size: 32 },
                TokenKind::F64 => ValType::Float { size: 64 },
                _ => panic!("invalid token kind during compiling type: {:?}", token),
            },
            Type::Ident(token) => self
                .name_to_type
                .get(token.value.as_ref().unwrap())
                .cloned()
                .ok_or(Error::UndeclaredSymbol(token.clone()))?,
            Type::Struct(strct) => {
                let mut fields = HashMap::new();
                for (index, field) in strct.fields.iter().enumerate() {
                    let name = field.name.value.as_ref().unwrap().clone();
                    let typ = self.compile_type(&field.typ)?;
                    fields.insert(name, ValTypeField { index, typ });
                }
                ValType::Struct { fields }
            }
        })
    }

    fn compile_expr(&self, expr: &Expr) -> ValType {
        // TODO: implement this
        match expr.kind {
            ExprKind::IntegerLit(_) => ValType::Int { signed: true, size: 32 },
            ExprKind::FloatLit(_) => ValType::Float { size: 32},
            ExprKind::BoolLit(_) => ValType::Bool,
            _ => todo!(),
        }
    }
}

struct FnAnalyzer {
    symbol_tables: Vec<HashMap<String, IndexType>>,
    return_type: Option<ValType>,
    counter: isize,
}

impl FnAnalyzer {
    fn new(fn_decl: &FnDecl, type_analyzer: &TypeAnalyzer) -> Result<Self, Error> {
        let mut table = HashMap::new();
        for (i, param) in fn_decl.params.iter().rev().enumerate() {
            let name = param.name.value.as_ref().unwrap().clone();
            let index = -(i as isize + 1);
            let typ = type_analyzer.compile_type(&param.typ)?;
            table.insert(name, IndexType { index, typ });
        }

        let return_type = fn_decl.ret_type.as_ref();
        let return_type = if let Some(t) = return_type {
            Some(type_analyzer.compile_type(t)?)
        } else {
            None
        };

        Ok(Self {
            symbol_tables: vec![table],
            return_type,
            counter: 0,
        })
    }
}

struct FnContext {
    symbol_tables: Vec<HashMap<String, IndexType>>,
    return_type: Option<ValType>,
    counter: isize,
}

#[derive(Debug, Clone)]
struct IndexType {
    index: isize,
    typ: ValType,
}

impl FnContext {
    fn new(fn_decl: &FnDecl, type_analyzer: &TypeAnalyzer) -> Result<Self, Error> {
        let mut table = HashMap::new();
        for (i, param) in fn_decl.params.iter().rev().enumerate() {
            let name = param.name.value.as_ref().unwrap().clone();
            let index = -(i as isize + 1);
            let typ = type_analyzer.compile_type(&param.typ)?;
            table.insert(name, IndexType { index, typ });
        }

        let return_type = fn_decl.ret_type.as_ref();
        let return_type = if let Some(t) = return_type {
            Some(type_analyzer.compile_type(t)?)
        } else {
            None
        };

        Ok(Self {
            symbol_tables: vec![table],
            return_type,
            counter: 0,
        })
    }

    fn add_block(&mut self) {
        self.symbol_tables.push(HashMap::new());
    }

    fn pop_block(&mut self) -> usize {
        self.symbol_tables.pop().unwrap().len()
    }

    fn add_symbol(&mut self, name: String, typ: ValType) {
        let index = self.counter;
        self.symbol_tables
            .last_mut()
            .unwrap()
            .insert(name, IndexType { index, typ });
        self.counter += 1;
    }

    fn find_symbol(&self, name: &str) -> Option<IndexType> {
        for block in self.symbol_tables.iter().rev() {
            if let Some(index) = block.get(name) {
                return Some(index.clone());
            }
        }
        None
    }
}
